type WalletResult = 
 variant {
   err: text;
   ok: AgentWallet;
 };
type TransformArgs = 
 record {
   context: blob;
   response: HttpResponsePayload;
 };
type ToolResult = 
 variant {
   err: text;
   ok: text;
 };
type TgStatus = 
 record {
   configured: bool;
   hasLlmConfig: bool;
   hasSecret: bool;
 };
type SignWithEcdsaResult = 
 variant {
   err: text;
   ok: SignWithEcdsaOut;
 };
type SignWithEcdsaOut = 
 record {
   derivationPathHex: vec text;
   keyName: text;
   messageHashHex: text;
   "principal": principal;
   principalText: text;
   signatureHex: text;
 };
type SessionSummary = 
 record {
   id: text;
   messageCount: nat;
   updatedAtNs: int;
 };
type SendResult = 
 variant {
   err: text;
   ok: SendOk;
 };
type SendOptions = 
 record {
   apiKey: text;
   includeHistory: bool;
   maxTokens: opt nat;
   model: text;
   provider: Provider;
   skillNames: vec text;
   systemPrompt: opt text;
   temperature: opt float64;
 };
type SendOk = 
 record {
   assistant: ChatMessage;
   raw: opt text;
 };
type SendIcrc1Result = 
 variant {
   err: text;
   ok: nat;
 };
type SendIcpResult = 
 variant {
   err: text;
   ok: nat;
 };
type SendEthResult = 
 variant {
   err: text;
   ok: text;
 };
type Role = 
 variant {
   assistant;
   system;
   tool;
   user;
 };
type Result = 
 variant {
   err: text;
   ok: text;
 };
type Provider = 
 variant {
   anthropic;
   google;
   openai;
 };
type ModelsResult = 
 variant {
   err: text;
   ok: vec text;
 };
type LlmTrace = 
 record {
   error: opt text;
   id: nat;
   model: text;
   provider: text;
   requestBody: text;
   responseBody: opt text;
   tsNs: int;
   url: text;
 };
type InHttpResponse = 
 record {
   body: blob;
   headers: vec HeaderField;
   status_code: nat16;
   streaming_strategy:
    opt
     variant {Callback: record {
                          callback: func () -> () query;
                          token: blob;
                        };};
   upgrade: opt bool;
 };
type InHttpRequest = 
 record {
   body: blob;
   headers: vec HeaderField;
   method: text;
   url: text;
 };
type HttpResponsePayload = 
 record {
   body: blob;
   headers: vec HttpHeader;
   status: nat;
 };
type HttpHeader = 
 record {
   name: text;
   value: text;
 };
type HookTrigger = 
 variant {
   command: text;
   messageContains: text;
 };
type HookEntry = 
 record {
   action: HookAction;
   enabled: bool;
   name: text;
   trigger: HookTrigger;
 };
type HookAction = 
 variant {
   reply: text;
   tool: record {
           args: vec text;
           name: text;
         };
 };
type HeaderField = 
 record {
   text;
   text;
 };
type EthAddressResult = 
 variant {
   err: text;
   ok: text;
 };
type EcdsaPublicKeyResult = 
 variant {
   err: text;
   ok: EcdsaPublicKeyOut;
 };
type EcdsaPublicKeyOut = 
 record {
   chainCodeHex: text;
   derivationPathHex: vec text;
   keyName: text;
   "principal": principal;
   principalText: text;
   publicKeyHex: text;
 };
type DiscordStatus = 
 record {
   configured: bool;
   hasLlmConfig: bool;
   hasProxySecret: bool;
 };
type CkEthStatus = 
 record {
   hasIcpswapBroker: bool;
   hasIcpswapQuoteUrl: bool;
   hasKongswapBroker: bool;
   hasKongswapQuoteUrl: bool;
 };
type ChatMessage = 
 record {
   content: text;
   role: Role;
   tsNs: int;
 };
type BuyCkEthResult = 
 variant {
   err: text;
   ok: text;
 };
type BalanceResult = 
 variant {
   err: text;
   ok: nat;
 };
type AgentWallet = 
 record {
   chainCodeHex: text;
   derivationPathHex: vec text;
   keyName: text;
   "principal": principal;
   principalText: text;
   publicKeyHex: text;
 };
service : {
  admin_has_provider_api_key: (provider: Provider) -> (bool) query;
  admin_set_cketh_broker: (canisterText: opt text) -> ();
  admin_set_cketh_brokers: (icpswapCanisterText: opt text,
   kongswapCanisterText: opt text) -> ();
  admin_set_cketh_quote_sources: (icpswapQuoteUrl: opt text,
   kongswapQuoteUrl: opt text) -> ();
  admin_set_discord: (proxySecret: opt text) -> ();
  admin_set_llm_opts: (opts: SendOptions) -> ();
  admin_set_provider_api_key: (provider: Provider, apiKey: text) -> ();
  admin_set_tg: (botToken: text, secretToken: opt text) -> ();
  admin_tg_set_webhook: (webhookUrl: text) -> (Result);
  agent_wallet: () -> (WalletResult);
  canister_principal: () -> (principal) query;
  cketh_status: () -> (CkEthStatus);
  dev_llm_traces: (afterId: nat, limit: nat) -> (vec LlmTrace) query;
  discord_status: () -> (DiscordStatus);
  ecdsa_public_key: (derivationPath: vec blob, keyName: opt text) ->
   (EcdsaPublicKeyResult);
  hooks_delete: (name: text) -> (bool);
  hooks_list: () -> (vec HookEntry);
  hooks_put_command_reply: (name: text, command: text, reply: text) -> (bool);
  hooks_put_command_tool: (name: text, command: text, toolName: text,
   toolArgs: vec text) -> (bool);
  hooks_put_message_reply: (name: text, keyword: text, reply: text) -> (bool);
  hooks_put_message_tool: (name: text, keyword: text, toolName: text,
   toolArgs: vec text) -> (bool);
  hooks_set_enabled: (name: text, enabled: bool) -> (bool);
  http_request: (req: InHttpRequest) -> (InHttpResponse) query;
  http_request_update: (req: InHttpRequest) -> (InHttpResponse);
  http_transform: (args: TransformArgs) -> (HttpResponsePayload) query;
  models_list: (provider: Provider, apiKey: text) -> (ModelsResult);
  owner_get: () -> (opt principal) query;
  polymarket_research: (topic: text, marketLimit: nat, newsLimit: nat) ->
   (Result);
  sessions_create: (sessionId: text) -> ();
  sessions_history: (sessionId: text, limit: nat) -> (vec ChatMessage);
  sessions_list: () -> (vec SessionSummary);
  sessions_list_for: ("principal": principal) -> (vec SessionSummary) query;
  sessions_reset: (sessionId: text) -> ();
  sessions_send: (sessionId: text, message: text, opts: SendOptions) ->
   (SendResult);
  sign_with_ecdsa: (messageHash: blob, derivationPath: vec blob, keyName:
   opt text) -> (SignWithEcdsaResult);
  skills_delete: (name: text) -> (bool);
  skills_get: (name: text) -> (opt text);
  skills_list: () -> (vec text);
  skills_put: (name: text, markdown: text) -> ();
  tg_status: () -> (TgStatus);
  tools_invoke: (name: text, args: vec text) -> (ToolResult);
  tools_list: () -> (vec text);
  wallet_balance_erc20: (network: text, rpcUrl: opt text, tokenAddress:
   text) -> (BalanceResult);
  wallet_balance_eth: (network: text, rpcUrl: opt text) -> (BalanceResult);
  wallet_balance_icp: () -> (BalanceResult);
  wallet_balance_icrc1: (ledgerPrincipalText: text) -> (BalanceResult);
  wallet_buy_cketh: (amountCkEthText: text, maxIcpE8s: nat64) ->
   (BuyCkEthResult);
  wallet_buy_cketh_one: (maxIcpE8s: nat64) -> (BuyCkEthResult);
  wallet_buy_erc20_uniswap: (network: text, rpcUrl: opt text, routerAddress:
   text, tokenInAddress: text, tokenOutAddress: text, fee: nat, amountIn:
   nat, amountOutMinimum: nat, deadline: nat, sqrtPriceLimitX96: nat) ->
   (SendEthResult);
  wallet_buy_uni: (network: text, rpcUrl: opt text, amountUniBase: nat,
   slippageBps: nat, deadline: nat) -> (SendEthResult);
  wallet_eth_address: () -> (EthAddressResult);
  wallet_send_erc20: (network: text, rpcUrl: opt text, tokenAddress: 
   text, toAddress: text, amount: nat) -> (SendEthResult);
  wallet_send_eth: (network: text, rpcUrl: opt text, toAddress: text,
   amountWei: nat) -> (SendEthResult);
  wallet_send_eth_raw: (network: text, rpcUrl: opt text, rawTxHex: text) ->
   (SendEthResult);
  wallet_send_icp: (toPrincipalText: text, amountE8s: nat64) ->
   (SendIcpResult);
  wallet_send_icrc1: (ledgerPrincipalText: text, toPrincipalText: text,
   amount: nat, fee: opt nat) -> (SendIcrc1Result);
  wallet_swap_uniswap: (network: text, rpcUrl: opt text, routerAddress: 
   text, tokenInAddress: text, tokenOutAddress: text, fee: nat, amountIn:
   nat, amountOutMinimum: nat, deadline: nat, sqrtPriceLimitX96: nat,
   autoApprove: bool) -> (SendEthResult);
  wallet_token_address: (network: text, symbol: text) -> (opt text) query;
  whoami: () -> (text);
}
